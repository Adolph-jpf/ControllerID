// 全局变量
let csvData = []; // 存储解析后的CSV数据
let waferMap = {}; // 存储晶圆映射数据
let currentChart = null; // 当前显示的图表实例
let rawFileContent = null; // 存储原始文件内容
let pointSize = 12; // 默认点大小
let referenceCoordinates = []; // 存储参考坐标，初始化为空数组
let excelFile = null; // 存储上传的Excel文件
let sbFailureCodes = []; // 存储所有故障代码
let selectedFailureCode = 'all'; // 当前选择的故障代码
let chart = null;
let locationStats = {};

// DOM元素
const csvFileInput = document.getElementById('csv-file');
const uploadBtn = document.getElementById('upload-btn');
const previewBtn = document.getElementById('preview-btn');
const fileInfoDiv = document.getElementById('file-info');
const filePreviewContainer = document.getElementById('file-preview-container');
const filePreviewDiv = document.getElementById('file-preview');
const predefinedCoordinatesSelect = document.getElementById('predefined-coordinates');
const loadPredefinedBtn = document.getElementById('load-predefined-btn');
const referenceFileUpload = document.getElementById('reference-file-upload');
const uploadReferenceFileBtn = document.getElementById('upload-reference-file-btn');
const referenceSheetSelect = document.getElementById('reference-sheet');
const loadReferenceBtn = document.getElementById('load-reference-btn');
const referenceInfoDiv = document.getElementById('reference-info');
const referencePreviewContainer = document.getElementById('reference-preview-container');
const referencePreviewDiv = document.getElementById('reference-preview');
const asicSelect = document.getElementById('asic-select');
const waferSelect = document.getElementById('wafer-select');
const generateMapBtn = document.getElementById('generate-map-btn');
const generateAllMapBtn = document.getElementById('generate-all-map-btn');
const exportExcelBtn = document.getElementById('export-excel-btn');
const exportImageBtn = document.getElementById('export-image-btn');
const statsDiv = document.getElementById('stats');
const pointSizeSlider = document.getElementById('point-size');
const pointSizeValue = document.getElementById('point-size-value');
const failureCodeSelect = document.getElementById('failure-code-select');
const updateDisplayBtn = document.getElementById('update-display-btn');

// 初始化
document.addEventListener('DOMContentLoaded', () => {
    // 禁用生成映射和导出按钮，直到数据加载完成
    generateMapBtn.disabled = true;
    generateAllMapBtn.disabled = true;
    exportExcelBtn.disabled = true;
    exportImageBtn.disabled = false;
    previewBtn.disabled = true;
    
    // 检查故障代码选择器是否存在
    if (!failureCodeSelect) {
        console.error('错误: 未找到故障代码选择器元素!');
        showStatusMessage('页面加载错误: 未找到故障代码选择器元素', 'error');
    } else {
        console.log('故障代码选择器已找到');
        
        // 添加一些测试故障代码
        sbFailureCodes = ['TEST1', 'TEST2', 'TEST3'];
        updateFailureCodeSelector();
        console.log('已添加测试故障代码到选择器');
    }
    
    // 将setFailureCode暴露为全局函数，以便HTML中的按钮可以调用
    window.setFailureCode = setFailureCode;
    console.log('已设置全局setFailureCode函数');
    
    // 暴露测试函数
    window.generateTestMap = generateTestMap;
    
    // 添加调试按钮
    const debugSection = document.createElement('div');
    debugSection.className = 'debug-section';
    debugSection.style.margin = '10px 0';
    debugSection.style.padding = '10px';
    debugSection.style.backgroundColor = '#f0f0f0';
    debugSection.style.border = '1px solid #ddd';
    debugSection.style.borderRadius = '4px';
    
    const debugTitle = document.createElement('h3');
    debugTitle.textContent = '调试区域';
    debugSection.appendChild(debugTitle);
    
    const debugBtn = document.createElement('button');
    debugBtn.textContent = '生成测试映射图';
    debugBtn.className = 'mini-button';
    debugBtn.style.marginRight = '10px';
    debugBtn.onclick = generateTestMap;
    debugSection.appendChild(debugBtn);
    
    const updateSelectBtn = document.createElement('button');
    updateSelectBtn.textContent = '刷新故障代码选择器';
    updateSelectBtn.className = 'mini-button';
    updateSelectBtn.onclick = function() {
        sbFailureCodes = ['DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4'];
        updateFailureCodeSelector();
        showStatusMessage('已刷新故障代码选择器', 'info');
    };
    debugSection.appendChild(updateSelectBtn);
    
    // 添加到页面底部
    document.querySelector('.container').appendChild(debugSection);
    
    // 添加事件监听器
    uploadBtn.addEventListener('click', handleFileUpload);
    previewBtn.addEventListener('click', previewFile);
    loadPredefinedBtn.addEventListener('click', loadPredefinedCoordinates);
    uploadReferenceFileBtn.addEventListener('click', handleReferenceFileUpload);
    loadReferenceBtn.addEventListener('click', loadReferenceCoordinates);
    csvFileInput.addEventListener('change', function() {
        // 当选择文件后启用预览按钮
        previewBtn.disabled = !csvFileInput.files.length;
    });
    referenceFileUpload.addEventListener('change', function() {
        // 当选择文件后启用上传按钮
        uploadReferenceFileBtn.disabled = !referenceFileUpload.files.length;
    });
    asicSelect.addEventListener('change', updateWaferOptions);
    generateMapBtn.addEventListener('click', generateWaferMap);
    generateAllMapBtn.addEventListener('click', generateAllWaferMap);
    exportExcelBtn.addEventListener('click', exportToExcel);
    exportImageBtn.addEventListener('click', exportImage);
    pointSizeSlider.addEventListener('input', () => {
        pointSize = parseInt(pointSizeSlider.value);
        pointSizeValue.textContent = pointSize;
        updateDisplay();
    });
    failureCodeSelect.addEventListener('change', () => {
        selectedFailureCode = failureCodeSelect.value;
        updateDisplay();
        console.log(`故障代码选择器值已变更为: ${selectedFailureCode}`);
    });
    updateDisplayBtn.addEventListener('click', updateDisplay);
    
    // 初始化文件上传
    const fileInput = document.getElementById('file-input');
    fileInput.addEventListener('change', handleFileSelect);
    
    // 初始化参考坐标选择器
    const coordinateSelect = document.getElementById('coordinate-select');
    
    // 初始化生成按钮
    const generateBtn = document.getElementById('generate-btn');
    generateBtn.addEventListener('click', generateWaferMap);
    
    const generateAllBtn = document.getElementById('generate-all-btn');
    generateAllBtn.addEventListener('click', generateAllWaferMap);
    
    // 初始化ASIC和Wafer选择器
    const asicSelect = document.getElementById('asic-select');
    const waferSelect = document.getElementById('wafer-select');
    
    asicSelect.addEventListener('change', updateWaferOptions);
    
    // 初始化导出按钮
    exportImageBtn.addEventListener('click', exportImage);
    
    const exportDataBtn = document.getElementById('export-data-btn');
    exportDataBtn.addEventListener('click', exportToExcel);
    
    // 加载预定义坐标
    loadPredefinedCoordinates();
});

// 加载参考文件列表
function loadReferenceFileList() {
    // 清空现有选项
    while (referenceSelect.options.length > 1) {
        referenceSelect.remove(1);
    }
    
    // 在本地环境中，直接使用模拟数据
    const files = [
        { name: 'INANDM_controller.xlsx', path: './reference/INANDM_controller.xlsx' },
        { name: 'INAND_WaferMap_Template.xlsx', path: './reference/INAND_WaferMap_Template.xlsx' },
        { name: 'INAND_WaferMap_2023.xlsx', path: './reference/INAND_WaferMap_2023.xlsx' },
        { name: 'INAND_WaferMap_2024.xlsx', path: './reference/INAND_WaferMap_2024.xlsx' }
    ];
    
    referenceFiles = files;
    
    // 添加到下拉列表
    files.forEach(file => {
        const option = document.createElement('option');
        option.value = file.path;
        option.textContent = file.name;
        referenceSelect.appendChild(option);
    });
    
    // 更新提示信息
    referenceInfoDiv.innerHTML = `本地模式：请确保您的参考文件位于 <code>reference</code> 文件夹中，并且文件名以 <code>INAND</code> 开头`;
}

// 处理参考文件选择
function handleReferenceFileSelect() {
    const selectedFilePath = referenceSelect.value;
    
    // 清空工作表选择
    while (referenceSheetSelect.options.length > 1) {
        referenceSheetSelect.remove(1);
    }
    
    if (!selectedFilePath) {
        referenceSheetSelect.disabled = true;
        return;
    }
    
    referenceInfoDiv.textContent = `已选择文件: ${selectedFilePath}`;
    
    // 在本地环境中，直接使用模拟数据
    // 添加更多可能的工作表名称，以适应不同的Excel文件
    const sheets = [
        'Sheet1', 'Sheet2', 'Sheet3', 
        'WaferMap', 'Coordinates', 'Data', 
        '坐标', '数据', '晶圆图', 
        'XY坐标', 'XY Coordinates',
        'Controller', 'ControllerID'
    ];
    
    sheets.forEach(sheet => {
        const option = document.createElement('option');
        option.value = sheet;
        option.textContent = sheet;
        referenceSheetSelect.appendChild(option);
    });
    
    referenceSheetSelect.disabled = false;
    referenceInfoDiv.textContent = `请选择包含坐标数据的工作表`;
}

// 处理参考文件上传
function handleReferenceFileUpload() {
    const file = referenceFileUpload.files[0];
    if (!file) {
        alert('请先选择参考文件');
        return;
    }
    
    // 检查文件类型
    const fileType = file.name.split('.').pop().toLowerCase();
    
    referenceInfoDiv.textContent = `正在处理文件: ${file.name}`;
    
    // 保存文件引用
    excelFile = file;
    
    if (fileType === 'csv') {
        // 处理CSV文件
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                // 使用PapaParse解析CSV文件
                Papa.parse(e.target.result, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            referenceInfoDiv.textContent = `解析CSV文件时出错: ${results.errors[0].message}`;
                            return;
                        }
                        
                        processCoordinatesData(results.data, 'CSV');
                    }
                });
            } catch (error) {
                console.error('解析CSV文件时出错:', error);
                referenceInfoDiv.textContent = `解析CSV文件时出错: ${error.message}`;
            }
        };
        
        reader.onerror = function() {
            referenceInfoDiv.textContent = '读取文件时出错';
        };
        
        reader.readAsText(file);
    } else if (fileType === 'xlsx' || fileType === 'xls') {
        // 处理Excel文件
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                // 使用SheetJS库解析Excel文件
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                
                // 获取所有工作表名称
                const sheetNames = workbook.SheetNames;
                
                // 更新工作表选择下拉框
                referenceSheetSelect.innerHTML = '';
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '请选择工作表';
                referenceSheetSelect.appendChild(defaultOption);
                
                sheetNames.forEach(sheetName => {
                    const option = document.createElement('option');
                    option.value = sheetName;
                    option.textContent = sheetName;
                    referenceSheetSelect.appendChild(option);
                });
                
                referenceSheetSelect.disabled = false;
                referenceInfoDiv.textContent = `已成功读取Excel文件，请选择包含坐标数据的工作表`;
                
            } catch (error) {
                console.error('解析Excel文件时出错:', error);
                referenceInfoDiv.textContent = `解析Excel文件时出错: ${error.message}`;
            }
        };
        
        reader.onerror = function() {
            referenceInfoDiv.textContent = '读取文件时出错';
        };
        
        reader.readAsArrayBuffer(file);
    } else {
        referenceInfoDiv.textContent = `不支持的文件类型: ${fileType}，请上传CSV、XLS或XLSX文件`;
    }
}

// 处理坐标数据
function processCoordinatesData(data, sourceType) {
    // 检查数据格式
    if (data.length === 0) {
        referenceInfoDiv.textContent = '文件中没有数据';
        return;
    }
    
    // 尝试识别X和Y列
    const firstRow = data[0];
    const keys = Object.keys(firstRow);
    
    // 查找可能的X和Y列名
    const possibleXColumns = ['X', 'x', 'X坐标', 'x坐标', 'X_COORD', 'x_coord'];
    const possibleYColumns = ['Y', 'y', 'Y坐标', 'y坐标', 'Y_COORD', 'y_coord'];
    
    let xColumn = null;
    let yColumn = null;
    
    // 查找X列
    for (const col of possibleXColumns) {
        if (keys.includes(col) || keys.some(k => k.toLowerCase() === col.toLowerCase())) {
            xColumn = keys.find(k => k.toLowerCase() === col.toLowerCase());
            break;
        }
    }
    
    // 查找Y列
    for (const col of possibleYColumns) {
        if (keys.includes(col) || keys.some(k => k.toLowerCase() === col.toLowerCase())) {
            yColumn = keys.find(k => k.toLowerCase() === col.toLowerCase());
            break;
        }
    }
    
    // 如果没有找到X或Y列，尝试使用前两列
    if (!xColumn && !yColumn && keys.length >= 2) {
        xColumn = keys[0];
        yColumn = keys[1];
    }
    
    if (!xColumn || !yColumn) {
        referenceInfoDiv.innerHTML = '无法识别X和Y坐标列。请确保文件包含X和Y列，或者前两列分别为X和Y坐标。';
        return;
    }
    
    // 提取坐标数据
    const coordinates = data.map(row => ({
        X: parseFloat(row[xColumn]),
        Y: parseFloat(row[yColumn])
    })).filter(coord => !isNaN(coord.X) && !isNaN(coord.Y));
    
    if (coordinates.length === 0) {
        referenceInfoDiv.textContent = '无法提取有效的坐标数据';
        return;
    }
    
    // 保存参考坐标
    referenceCoordinates = coordinates;
    
    // 显示预览
    showReferencePreview(coordinates);
    
    referenceInfoDiv.innerHTML = `成功从${sourceType}文件加载 ${coordinates.length} 个参考坐标点<br>
    <small>使用列: X=${xColumn}, Y=${yColumn}</small>`;
    
    // 如果已经生成了映射图，更新显示
    if (waferMap && Object.keys(waferMap).length > 0) {
        updateDisplay();
    }
}

// 显示参考坐标预览
function showReferencePreview(data) {
    // 创建表格
    let tableHTML = '<table>';
    
    // 添加表头
    tableHTML += '<tr><th>X坐标</th><th>Y坐标</th></tr>';
    
    // 添加数据行（最多显示20行）
    const rowsToShow = Math.min(data.length, 20);
    for (let i = 0; i < rowsToShow; i++) {
        tableHTML += `<tr><td>${data[i].X}</td><td>${data[i].Y}</td></tr>`;
    }
    
    tableHTML += '</table>';
    
    if (data.length > rowsToShow) {
        tableHTML += `<p>显示前 ${rowsToShow} 个坐标点，共 ${data.length} 个</p>`;
    }
    
    // 显示预览
    referencePreviewDiv.innerHTML = tableHTML;
    referencePreviewContainer.style.display = 'block';
}

// 预览文件
function previewFile() {
    const file = csvFileInput.files[0];
    if (!file) {
        alert('请先选择CSV文件');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        rawFileContent = e.target.result;
        
        // 显示文件前10行
        const lines = rawFileContent.split('\n').slice(0, 10);
        
        // 尝试检测分隔符
        const possibleDelimiters = [',', ';', '\t', '|'];
        let bestDelimiter = ',';
        let maxFields = 0;
        
        for (const delimiter of possibleDelimiters) {
            const fields = lines[0].split(delimiter);
            
            if (fields.length > maxFields) {
                maxFields = fields.length;
                bestDelimiter = delimiter;
            }
        }
        
        // 创建表格显示预览
        let tableHTML = '<table>';
        
        // 处理每一行
        lines.forEach((line, index) => {
            const cells = line.split(bestDelimiter);
            
            if (index === 0) {
                // 表头
                tableHTML += '<tr>';
                cells.forEach(cell => {
                    tableHTML += `<th>${cell}</th>`;
                });
                tableHTML += '</tr>';
            } else {
                // 数据行
                tableHTML += '<tr>';
                cells.forEach(cell => {
                    tableHTML += `<td>${cell}</td>`;
                });
                tableHTML += '</tr>';
            }
        });
        
        tableHTML += '</table>';
        
        // 显示预览
        filePreviewDiv.innerHTML = tableHTML;
        filePreviewContainer.style.display = 'block';
        
        // 显示分隔符信息
        fileInfoDiv.textContent = `检测到的分隔符: "${bestDelimiter === '\t' ? 'Tab' : bestDelimiter}", 字段数: ${maxFields}`;
    };
    
    reader.readAsText(file);
}

// 处理文件上传
function handleFileUpload() {
    const file = csvFileInput.files[0];
    if (!file) {
        alert('请先选择CSV文件');
        return;
    }
    
    fileInfoDiv.textContent = `正在处理文件: ${file.name}`;
    
    // 首先尝试检测分隔符
    const reader = new FileReader();
    reader.onload = function(e) {
        const sample = e.target.result.slice(0, 2000); // 读取前2000个字符作为样本
        
        // 检测可能的分隔符
        const possibleDelimiters = [',', ';', '\t', '|'];
        let bestDelimiter = ',';
        let maxFields = 0;
        
        for (const delimiter of possibleDelimiters) {
            const result = Papa.parse(sample, {
                delimiter: delimiter,
                preview: 5, // 只检查前5行
                header: true
            });
            
            // 计算平均字段数
            const avgFields = result.data.reduce((sum, row) => sum + Object.keys(row).length, 0) / result.data.length;
            
            if (avgFields > maxFields) {
                maxFields = avgFields;
                bestDelimiter = delimiter;
            }
        }
        
        // 使用检测到的最佳分隔符解析整个文件
        Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            delimiter: bestDelimiter,
            encoding: "UTF-8",
            skipEmptyLines: true,
            complete: function(results) {
                if (results.errors.length > 0) {
                    // 显示详细错误信息
                    const errorMsg = `解析错误: ${results.errors[0].message}，行: ${results.errors[0].row || '未知'}`;
                    fileInfoDiv.textContent = errorMsg;
                    console.error('CSV解析错误:', results.errors);
                    
                    // 尝试提供更多帮助信息
                    if (results.errors[0].message.includes('Too few fields')) {
                        fileInfoDiv.innerHTML = `${errorMsg}<br><br>可能的原因:<br>
                        1. CSV文件使用了非标准分隔符（尝试了: ${bestDelimiter}）<br>
                        2. 文件编码问题<br>
                        3. 文件格式不正确<br><br>
                        建议: 请确保CSV文件使用标准格式，包含9个字段: stlot,teststep,asic,wafer,X,Y,HB,SB,ASICID`;
                    }
                    return;
                }
                
                // 检查是否有预期的列
                const requiredColumns = ['stlot', 'teststep', 'asic', 'wafer', 'X', 'Y', 'HB', 'SB', 'ASICID'];
                const missingColumns = requiredColumns.filter(col => !results.meta.fields.includes(col));
                
                if (missingColumns.length > 0) {
                    fileInfoDiv.innerHTML = `文件缺少必要的列: ${missingColumns.join(', ')}<br>
                    找到的列: ${results.meta.fields.join(', ')}<br>
                    请确保CSV文件包含所有必要的列。`;
                    return;
                }
                
                csvData = results.data;
                fileInfoDiv.textContent = `成功加载 ${csvData.length} 条记录，使用分隔符: "${bestDelimiter}"`;
                
                // 检查SB列的值，预处理故障代码
                console.log('扫描SB列值...');
                const sbValues = new Set();
                const nonZeroOneSbValues = new Set();
                
                results.data.forEach(row => {
                    if (row.SB !== undefined && row.SB !== null) {
                        const sbVal = String(row.SB);
                        sbValues.add(sbVal);
                        if (sbVal !== '0' && sbVal !== '1') {
                            nonZeroOneSbValues.add(sbVal);
                        }
                    }
                });
                
                console.log(`SB列中共有 ${sbValues.size} 种不同的值:`, Array.from(sbValues));
                console.log(`SB列中共有 ${nonZeroOneSbValues.size} 种非0/1的值:`, Array.from(nonZeroOneSbValues));
                
                // 特别重要：直接硬编码一些故障代码用于测试
                if (nonZeroOneSbValues.size === 0) {
                    console.log('警告: 未找到非0/1的故障代码，添加测试故障代码');
                    nonZeroOneSbValues.add('C012');
                    nonZeroOneSbValues.add('E001');
                    nonZeroOneSbValues.add('F123');
                }
                
                // 手动执行DOM检查
                console.log('故障代码选择器DOM检查:');
                console.log('选择器元素是否存在:', !!failureCodeSelect);
                if (failureCodeSelect) {
                    console.log('选择器Display属性:', window.getComputedStyle(failureCodeSelect).display);
                    console.log('选择器Visibility属性:', window.getComputedStyle(failureCodeSelect).visibility);
                    console.log('选择器当前选项数:', failureCodeSelect.options.length);
                }
                
                // 更新故障代码全局变量
                sbFailureCodes = Array.from(nonZeroOneSbValues).sort();
                
                // 更新故障代码选择器
                updateFailureCodeSelector();
                
                // 手动检查更新后的选择器状态
                console.log('更新后选择器选项数:', failureCodeSelect.options.length);
                for (let i = 0; i < failureCodeSelect.options.length; i++) {
                    console.log(`选项 ${i}: 值='${failureCodeSelect.options[i].value}', 文本='${failureCodeSelect.options[i].text}'`);
                }
                
                // 提取唯一的ASIC批次
                const asicBatches = [...new Set(csvData.map(row => row.asic))].filter(Boolean);
                
                // 更新ASIC选择下拉框
                asicSelect.innerHTML = '';
                asicBatches.forEach(asic => {
                    const option = document.createElement('option');
                    option.value = asic;
                    option.textContent = asic;
                    asicSelect.appendChild(option);
                });
                
                // 触发ASIC变更事件，更新晶圆选项
                updateWaferOptions();
                
                // 启用生成映射按钮
                generateMapBtn.disabled = false;
                generateAllMapBtn.disabled = false;
                
                showStatusMessage(`文件已成功加载，检测到 ${sbFailureCodes.length} 种故障代码`, 'success');
            }
        });
    };
    
    reader.readAsText(file);
}

// 更新晶圆选项
function updateWaferOptions() {
    const selectedAsic = asicSelect.value;
    
    // 获取选定ASIC批次的所有晶圆
    const wafers = [...new Set(csvData
        .filter(row => row.asic === selectedAsic)
        .map(row => row.wafer))]
        .filter(Boolean)
        .sort((a, b) => a - b);
    
    // 更新晶圆选择下拉框
    waferSelect.innerHTML = '';
    wafers.forEach(wafer => {
        const option = document.createElement('option');
        option.value = wafer;
        option.textContent = wafer;
        waferSelect.appendChild(option);
    });
}

// 生成晶圆映射
function generateWaferMap() {
    const selectedAsic = asicSelect.value;
    const selectedWafer = waferSelect.value;
    
    if (!selectedAsic || !selectedWafer) {
        showStatusMessage('请选择ASIC批次和晶圆编号', 'error');
        alert('请选择ASIC批次和晶圆编号');
        return;
    }
    
    if (csvData.length === 0) {
        showStatusMessage('请先上传并解析CSV文件', 'error');
        alert('请先上传并解析CSV文件');
        return;
    }
    
    showStatusMessage(`正在生成晶圆映射 - ASIC: ${selectedAsic}, Wafer: ${selectedWafer}`, 'info');
    
    // 筛选选定的ASIC和晶圆数据
    const waferData = csvData.filter(row => 
        row.asic === selectedAsic && row.wafer === selectedWafer
    );
    
    if (waferData.length === 0) {
        showStatusMessage(`未找到ASIC: ${selectedAsic}, Wafer: ${selectedWafer}的数据`, 'error');
        alert(`未找到ASIC: ${selectedAsic}, Wafer: ${selectedWafer}的数据`);
        return;
    }
    
    try {
        // 计算每个位置的统计数据
        const locationStats = calculateLocationStats(waferData);
        
        // 保存到全局变量
        waferMap = locationStats;
        
        // 重置故障代码选择器为"所有故障代码"
        failureCodeSelect.value = 'all';
        selectedFailureCode = 'all';
        
        // 绘制晶圆映射图
        drawWaferMap(locationStats, `晶圆映射 - ASIC: ${selectedAsic}, Wafer: ${selectedWafer}`);
        
        // 显示统计信息
        displayStats(locationStats);
        
        // 启用导出按钮
        exportExcelBtn.disabled = false;
        exportImageBtn.disabled = false;
        
        showStatusMessage(`晶圆映射生成成功 - ASIC: ${selectedAsic}, Wafer: ${selectedWafer}`, 'success');
    } catch (error) {
        console.error(`生成晶圆映射时出错:`, error);
        showStatusMessage(`生成晶圆映射时出错: ${error.message}`, 'error');
    }
}

// 计算每个位置的统计数据
function calculateLocationStats(waferData) {
    const locationStats = {};
    const failureCodes = new Set(); // 使用Set来收集唯一的故障代码
    let totalFailureDies = 0; // 统计总故障DIE数量
    
    console.log(`开始处理 ${waferData.length} 条DIE数据`);
    
    // 首先，调试检查SB列数据
    const sbValues = waferData.map(die => die.SB);
    const uniqueSbValues = [...new Set(sbValues)];
    console.log(`所有SB值:`, uniqueSbValues);
    
    // 获取所有唯一的X,Y坐标
    waferData.forEach((die, index) => {
        // 每500条数据输出一次进度
        if (index % 500 === 0) {
            console.log(`已处理 ${index}/${waferData.length} 条数据`);
        }
        
        const key = `${die.X},${die.Y}`;
        
        if (!locationStats[key]) {
            locationStats[key] = {
                X: die.X,
                Y: die.Y,
                locationTotal: 0,
                failureDies: {}, // 使用对象按故障代码存储故障DIE
                allFailureDies: [] // 存储所有故障DIE
            };
        }
        
        // 增加位置总数
        locationStats[key].locationTotal += 1;
        
        // 检查SB值
        if (die.SB !== undefined && die.SB !== null) {
            const sbVal = String(die.SB); // 不转换为小写，保留原始格式
            
            // 输出一些重要的SB值
            if (index < 20) {
                console.log(`索引 ${index} 的DIE SB值: '${sbVal}', 类型: ${typeof die.SB}`);
            }
            
            // 如果SB不是"0"或"1"，则视为故障
            if (sbVal !== '0' && sbVal !== '1') {
                // 收集故障代码
                failureCodes.add(sbVal);
                totalFailureDies++;
                
                // 按故障代码归类
                if (!locationStats[key].failureDies[sbVal]) {
                    locationStats[key].failureDies[sbVal] = [];
                }
                
                const failureDie = {
                    ...die,
                    sbCode: sbVal
                };
                
                // 添加到对应故障代码列表
                locationStats[key].failureDies[sbVal].push(failureDie);
                
                // 添加到所有故障列表
                locationStats[key].allFailureDies.push(failureDie);
            }
        }
    });
    
    console.log(`收集到的故障代码:`, Array.from(failureCodes));
    
    // 更新全局故障代码列表
    sbFailureCodes = Array.from(failureCodes).sort();
    
    // 打印调试信息
    console.log(`检测到 ${sbFailureCodes.length} 种故障代码:`, sbFailureCodes);
    console.log(`总故障DIE数量: ${totalFailureDies}`);
    
    // 更新故障代码选择器
    updateFailureCodeSelector();
    
    return locationStats;
}

// 根据选定的故障代码计算故障率
function calculateFailureRateByCode(locationStats, failureCode) {
    console.log(`开始计算故障率，故障代码: '${failureCode}'`);
    
    const result = {};
    let totalLocations = 0;
    let totalFailureDies = 0;
    
    Object.entries(locationStats).forEach(([key, location]) => {
        const newLocation = { ...location };
        
        // 如果是"all"，计算所有故障的总数
        if (failureCode === 'all') {
            newLocation.failureTotal = location.allFailureDies ? location.allFailureDies.length : 0;
        } 
        // 否则只计算特定故障代码的数量
        else {
            // 确保failureDies对象存在
            if (location.failureDies && location.failureDies[failureCode]) {
                newLocation.failureTotal = location.failureDies[failureCode].length;
            } else {
                newLocation.failureTotal = 0;
            }
        }
        
        // 计算故障率
        if (newLocation.locationTotal > 0) {
            newLocation.rate = newLocation.failureTotal / newLocation.locationTotal;
        } else {
            newLocation.rate = 0;
        }
        
        // 累计总数
        totalLocations += newLocation.locationTotal;
        totalFailureDies += newLocation.failureTotal;
        
        result[key] = newLocation;
    });
    
    console.log(`计算完成, 总位置: ${Object.keys(result).length}, 总DIE: ${totalLocations}, 故障DIE: ${totalFailureDies}`);
    
    return result;
}

// 更新故障代码选择器
function updateFailureCodeSelector() {
    console.log(`正在更新故障代码选择器，共 ${sbFailureCodes.length} 种故障代码`);
    
    try {
        // 首先验证DOM元素是否存在
        if (!failureCodeSelect) {
            console.error('故障代码选择器DOM元素未找到!');
            return;
        }
        
        // 清空所有现有选项（完全重建）
        failureCodeSelect.innerHTML = '';
        
        // 添加"所有故障代码"选项
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = '所有故障代码';
        failureCodeSelect.appendChild(allOption);
        console.log('添加"所有故障代码"选项');
        
        // 添加每个故障代码作为选项
        if (sbFailureCodes.length > 0) {
            sbFailureCodes.forEach(code => {
                // 确保code是字符串并且不为空
                if (code !== undefined && code !== null) {
                    const codeStr = String(code);
                    const option = document.createElement('option');
                    option.value = codeStr;
                    option.textContent = `故障代码: ${codeStr}`;
                    failureCodeSelect.appendChild(option);
                    console.log(`添加故障代码选项: '${codeStr}'`);
                } else {
                    console.warn(`跳过无效的故障代码:`, code);
                }
            });
            
            // 启用选择器
            failureCodeSelect.disabled = false;
        } else {
            console.warn('没有故障代码可供选择');
            // 如果没有故障代码，禁用选择器
            failureCodeSelect.disabled = true;
        }
        
        // 添加测试选项（确保至少有一个非"all"选项）
        if (failureCodeSelect.options.length <= 1) {
            console.log('添加测试选项以确保下拉菜单正常工作');
            const testOption = document.createElement('option');
            testOption.value = 'TEST';
            testOption.textContent = '测试故障代码';
            failureCodeSelect.appendChild(testOption);
        }
        
        // 调试：检查所有选项
        console.log(`故障代码选择器中共有 ${failureCodeSelect.options.length} 个选项:`);
        for (let i = 0; i < failureCodeSelect.options.length; i++) {
            console.log(`  选项 ${i}: 值='${failureCodeSelect.options[i].value}', 文本='${failureCodeSelect.options[i].text}'`);
        }
        
        // 确保选择器是可见的
        failureCodeSelect.style.display = 'inline-block';
        failureCodeSelect.style.visibility = 'visible';
        
        console.log(`故障代码选择器更新完成，当前选中值: ${failureCodeSelect.value}`);
    } catch (error) {
        console.error(`更新故障代码选择器时出错:`, error);
    }
}

// 筛选特定故障代码的数据
function filterLocationStatsByFailureCode(locationStats, failureCode) {
    // 如果选择了"all"，返回所有数据
    if (failureCode === 'all') {
        return locationStats;
    }
    
    // 创建一个新的对象存储筛选后的数据
    const filteredStats = {};
    
    // 遍历所有位置
    Object.entries(locationStats).forEach(([key, location]) => {
        // 如果该位置有指定的故障代码
        if (location.failureDies && location.failureDies[failureCode]) {
            // 创建该位置的副本
            const filteredLocation = { ...location };
            
            // 只保留指定故障代码的故障DIE
            const selectedDies = location.failureDies[failureCode] || [];
            
            // 更新故障总数和故障率
            filteredLocation.failureTotal = selectedDies.length;
            
            if (filteredLocation.locationTotal > 0) {
                filteredLocation.rate = filteredLocation.failureTotal / filteredLocation.locationTotal;
            } else {
                filteredLocation.rate = 0;
            }
            
            // 只保留当前选择的故障代码
            filteredLocation.failureDies = { [failureCode]: selectedDies };
            filteredLocation.allFailureDies = selectedDies;
            
            // 添加到筛选后的数据中
            filteredStats[key] = filteredLocation;
        } else {
            // 如果没有指定故障代码，则清零故障相关数据
            filteredStats[key] = {
                ...location,
                failureTotal: 0,
                rate: 0,
                failureDies: {},
                allFailureDies: []
            };
        }
    });
    
    return filteredStats;
}

// 绘制晶圆映射图
function drawWaferMap(locationStats, title) {
    const canvas = document.getElementById('wafer-map');
    
    console.log(`开始绘制晶圆映射，故障代码: '${selectedFailureCode}'`);
    
    // 如果已有图表，销毁它
    if (currentChart) {
        currentChart.destroy();
    }
    
    // 根据选择的故障代码计算故障率
    const statsWithRate = calculateFailureRateByCode(locationStats, selectedFailureCode);
    
    // 提取所有X和Y坐标
    let locations = Object.values(statsWithRate);
    
    console.log(`计算了 ${locations.length} 个位置的故障率`);
    
    // 更新标题，显示当前选择的故障代码
    if (selectedFailureCode !== 'all') {
        title = `${title} - 故障代码: ${selectedFailureCode}`;
    }
    
    // 如果有参考坐标，使用参考坐标
    if (referenceCoordinates && referenceCoordinates.length > 0) {
        console.log(`使用 ${referenceCoordinates.length} 个参考坐标`);
        
        // 创建一个包含所有参考坐标的映射
        const referenceMap = {};
        referenceCoordinates.forEach(coord => {
            const key = `${coord.X},${coord.Y}`;
            referenceMap[key] = {
                X: coord.X,
                Y: coord.Y,
                locationTotal: 0,
                failureTotal: 0,
                rate: null
            };
        });
        
        // 将实际数据合并到参考坐标中
        Object.entries(statsWithRate).forEach(([key, loc]) => {
            // 如果参考坐标中存在这个位置，则更新它
            if (referenceMap[key]) {
                referenceMap[key] = loc;
            }
        });
        
        // 使用合并后的坐标
        locations = Object.values(referenceMap);
        console.log(`合并后共有 ${locations.length} 个坐标点`);
    }
    
    // 确保所有坐标都是数字
    locations = locations.filter(loc => {
        return !isNaN(loc.X) && !isNaN(loc.Y);
    });
    
    if (locations.length === 0) {
        alert('没有有效的坐标数据');
        return;
    }

    // 剩余代码保持不变
    const xValues = locations.map(loc => loc.X);
    const yValues = locations.map(loc => loc.Y);
    
    // 计算X和Y的范围
    const xMin = Math.min(...xValues);
    const xMax = Math.max(...xValues);
    const yMin = Math.min(...yValues);
    const yMax = Math.max(...yValues);
    
    // 创建矩阵数据
    const matrixData = [];
    
    // 为每个可能的X,Y坐标创建数据点
    for (let y = yMin; y <= yMax; y++) {
        for (let x = xMin; x <= xMax; x++) {
            const key = `${x},${y}`;
            const locationData = statsWithRate[key];
            
            // 创建数据点
            const dataPoint = {
                x: x,
                y: y,
                v: locationData ? locationData.rate : null, // 故障率
                locationTotal: locationData ? locationData.locationTotal : 0,
                failureTotal: locationData ? locationData.failureTotal : 0
            };
            
            matrixData.push(dataPoint);
        }
    }
    
    // 获取当前点大小
    const currentPointSize = parseInt(pointSizeSlider.value) || 6;
    pointSizeValue.textContent = currentPointSize;
    
    // 使用热图代替矩阵图，因为矩阵图可能有兼容性问题
    const config = {
        type: 'scatter',
        data: {
            datasets: [{
                label: '故障率',
                data: matrixData.map(point => ({
                    x: point.x,
                    y: point.y,
                    // 添加自定义属性
                    locationTotal: point.locationTotal,
                    failureTotal: point.failureTotal,
                    rate: point.v
                })),
                backgroundColor: function(context) {
                    const value = context.raw.rate;
                    if (value === null) {
                        return 'rgba(200, 200, 200, 0.1)';
                    }
                    const r = Math.floor(255 * value);
                    const g = Math.floor(255 * (1 - value));
                    const b = 0;
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                },
                pointStyle: 'rect',
                pointRadius: currentPointSize,
                pointHoverRadius: currentPointSize + 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const point = context[0].raw;
                            return `坐标: X=${point.x}, Y=${point.y}`;
                        },
                        label: function(context) {
                            const point = context.raw;
                            if (point.rate === null) {
                                return '无数据';
                            }
                            
                            // 根据选择的故障代码显示不同的提示文本
                            if (selectedFailureCode !== 'all') {
                                return [
                                    `DIE总数: ${point.locationTotal}`,
                                    `故障数(${selectedFailureCode}): ${point.failureTotal}`,
                                    `故障率: ${(point.rate * 100).toFixed(2)}%`
                                ];
                            } else {
                                return [
                                    `DIE总数: ${point.locationTotal}`,
                                    `故障数(所有): ${point.failureTotal}`,
                                    `故障率: ${(point.rate * 100).toFixed(2)}%`
                                ];
                            }
                        }
                    }
                },
                legend: {
                    display: false
                },
                title: {
                    display: true,
                    text: title || `晶圆映射 - ASIC: ${asicSelect.value}, Wafer: ${waferSelect.value}`
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    min: xMin - 0.5,
                    max: xMax + 0.5,
                    title: {
                        display: true,
                        text: 'X坐标'
                    },
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            if (Number.isInteger(value)) {
                                return value;
                            }
                            return '';
                        }
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.1)'
                    }
                },
                y: {
                    type: 'linear',
                    min: yMin - 0.5,
                    max: yMax + 0.5,
                    reverse: true, // 使Y轴从上到下增加
                    title: {
                        display: true,
                        text: 'Y坐标'
                    },
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            if (Number.isInteger(value)) {
                                return value;
                            }
                            return '';
                        }
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.1)'
                    }
                }
            }
        }
    };
    
    // 创建图表
    currentChart = new Chart(canvas, config);
    
    // 调整canvas大小
    canvas.parentElement.style.height = '600px';
}

// 显示统计信息
function displayStats(locationStats) {
    const locations = Object.values(locationStats);
    
    // 计算总体统计信息
    const totalLocations = locations.length;
    const totalDies = locations.reduce((sum, loc) => sum + loc.locationTotal, 0);
    const totalFailures = locations.reduce((sum, loc) => sum + (loc.failureTotal || 0), 0);
    const overallFailureRate = totalDies > 0 ? totalFailures / totalDies : 0;
    
    // 找出故障率最高的位置
    const highestFailureLocation = [...locations]
        .filter(loc => loc.rate !== null && loc.rate > 0)
        .sort((a, b) => b.rate - a.rate)[0];
    
    // 统计所有故障代码列表
    let sbCodeCounts = {};
    const allFailureDies = {};
    
    // 如果显示所有故障代码，则统计各个故障代码的数量
    if (selectedFailureCode === 'all') {
        locations.forEach(loc => {
            if (loc.failureDies) {
                Object.entries(loc.failureDies).forEach(([code, dies]) => {
                    if (!sbCodeCounts[code]) {
                        sbCodeCounts[code] = 0;
                        allFailureDies[code] = [];
                    }
                    sbCodeCounts[code] += dies.length;
                    allFailureDies[code] = allFailureDies[code].concat(dies);
                });
            }
        });
    } 
    // 如果只显示特定故障代码，则只统计该故障代码
    else {
        sbCodeCounts[selectedFailureCode] = totalFailures;
        allFailureDies[selectedFailureCode] = [];
        locations.forEach(loc => {
            if (loc.failureDies && loc.failureDies[selectedFailureCode]) {
                allFailureDies[selectedFailureCode] = allFailureDies[selectedFailureCode].concat(
                    loc.failureDies[selectedFailureCode]
                );
            }
        });
    }
    
    // 按数量排序故障代码
    const sortedSbCodes = Object.entries(sbCodeCounts)
        .sort((a, b) => b[1] - a[1])
        .map(([code, count]) => ({ code, count }));
    
    // 构建HTML
    let statsHTML = `
        <h3>统计信息${selectedFailureCode !== 'all' ? ` - 故障代码: ${selectedFailureCode}` : ''}</h3>
        <p><strong>总位置数:</strong> ${totalLocations}</p>
        <p><strong>总DIE数:</strong> ${totalDies}</p>
        <p><strong>总故障数:</strong> ${totalFailures}</p>
        <p><strong>整体故障率:</strong> ${(overallFailureRate * 100).toFixed(2)}%</p>
    `;
    
    // 如果是查看特定故障代码，显示该代码的详细信息
    if (selectedFailureCode !== 'all') {
        const diesWithSelectedCode = allFailureDies[selectedFailureCode] || [];
        
        if (diesWithSelectedCode.length > 0) {
            statsHTML += `
                <h4>故障代码 ${selectedFailureCode} DIE列表:</h4>
                <div class="failure-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <th style="border: 1px solid #ccc; padding: 4px;">ASICID</th>
                            <th style="border: 1px solid #ccc; padding: 4px;">X</th>
                            <th style="border: 1px solid #ccc; padding: 4px;">Y</th>
                            <th style="border: 1px solid #ccc; padding: 4px;">SB</th>
                        </tr>
            `;
            
            // 显示所有DIE，但最多100个
            const diesToShow = diesWithSelectedCode.slice(0, 100);
            diesToShow.forEach(die => {
                statsHTML += `
                    <tr>
                        <td style="border: 1px solid #ccc; padding: 4px;">${die.ASICID || '-'}</td>
                        <td style="border: 1px solid #ccc; padding: 4px;">${die.X}</td>
                        <td style="border: 1px solid #ccc; padding: 4px;">${die.Y}</td>
                        <td style="border: 1px solid #ccc; padding: 4px;">${die.SB}</td>
                    </tr>
                `;
            });
            
            statsHTML += `</table>`;
            
            statsHTML += `</div>`;
        } else {
            statsHTML += `<p>未找到故障代码 ${selectedFailureCode} 的DIE</p>`;
        }
    } 
    // 否则显示所有故障代码的统计
    else {
        // 添加故障代码统计
        if (sortedSbCodes.length > 0) {
            statsHTML += `
                <h4>故障代码统计:</h4>
                <div class="sb-code-stats" style="margin-bottom: 15px;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <th style="border: 1px solid #ccc; padding: 4px;">故障代码</th>
                            <th style="border: 1px solid #ccc; padding: 4px;">数量</th>
                            <th style="border: 1px solid #ccc; padding: 4px;">占比</th>
                            <th style="border: 1px solid #ccc; padding: 4px;">操作</th>
                        </tr>
            `;
            
            sortedSbCodes.forEach(({ code, count }) => {
                const percentage = totalFailures > 0 ? (count / totalFailures * 100).toFixed(2) : '0.00';
                statsHTML += `
                    <tr>
                        <td style="border: 1px solid #ccc; padding: 4px;">${code}</td>
                        <td style="border: 1px solid #ccc; padding: 4px;">${count}</td>
                        <td style="border: 1px solid #ccc; padding: 4px;">${percentage}%</td>
                        <td style="border: 1px solid #ccc; padding: 4px;">
                            <button onclick="setFailureCode('${code}')" class="mini-button">显示此故障</button>
                        </td>
                    </tr>
                `;
            });
            
            statsHTML += `</table></div>`;
        }
        
        // 添加故障位置信息
        if (highestFailureLocation) {
            statsHTML += `
                <h4>故障率最高位置:</h4>
                <p>X: ${highestFailureLocation.X}, Y: ${highestFailureLocation.Y}</p>
                <p>故障率: ${(highestFailureLocation.rate * 100).toFixed(2)}%</p>
            `;
        }
        
        // 为每种故障代码显示DIE列表（取前3种最常见的故障代码）
        const topFailureCodes = sortedSbCodes.slice(0, 3);
        
        if (topFailureCodes.length > 0) {
            statsHTML += `<h4>故障DIE详情:</h4>`;
            
            topFailureCodes.forEach(({ code }) => {
                const diesWithCode = allFailureDies[code] || [];
                if (diesWithCode.length > 0) {
                    statsHTML += `
                        <h5>故障代码 ${code} DIE列表 (前10个):
                        <button onclick="setFailureCode('${code}')" class="mini-button">显示所有</button></h5>
                        <div class="failure-list" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr>
                                    <th style="border: 1px solid #ccc; padding: 4px;">ASICID</th>
                                    <th style="border: 1px solid #ccc; padding: 4px;">X</th>
                                    <th style="border: 1px solid #ccc; padding: 4px;">Y</th>
                                    <th style="border: 1px solid #ccc; padding: 4px;">SB</th>
                                </tr>
                    `;
                    
                    // 显示前10个DIE
                    const diesToShow = diesWithCode.slice(0, 10);
                    diesToShow.forEach(die => {
                        statsHTML += `
                            <tr>
                                <td style="border: 1px solid #ccc; padding: 4px;">${die.ASICID || '-'}</td>
                                <td style="border: 1px solid #ccc; padding: 4px;">${die.X}</td>
                                <td style="border: 1px solid #ccc; padding: 4px;">${die.Y}</td>
                                <td style="border: 1px solid #ccc; padding: 4px;">${die.SB}</td>
                            </tr>
                        `;
                    });
                    
                    statsHTML += `</table>`;
                    
                    if (diesWithCode.length > 10) {
                        statsHTML += `<p>显示 ${diesToShow.length} 个，共 ${diesWithCode.length} 个</p>`;
                    }
                    
                    statsHTML += `</div>`;
                }
            });
        } else {
            statsHTML += `<p>没有发现故障DIE</p>`;
        }
    }
    
    statsDiv.innerHTML = statsHTML;
}

// 显示状态消息
function showStatusMessage(message, type = 'info') {
    const statusDiv = document.getElementById('status-message');
    if (!statusDiv) {
        console.error('未找到状态消息元素!');
        return;
    }
    
    // 清除现有类
    statusDiv.className = 'status-message';
    
    // 添加新类
    statusDiv.classList.add(type);
    
    // 确保消息显示
    statusDiv.style.display = 'block';
    
    // 设置消息
    statusDiv.textContent = message;
    console.log(`显示${type}消息: ${message}`);
    
    // 如果是成功或信息消息，3秒后自动隐藏
    if (type === 'success' || type === 'info') {
        setTimeout(() => {
            statusDiv.style.opacity = '0';
            setTimeout(() => {
                statusDiv.style.display = 'none';
                statusDiv.style.opacity = '1';
            }, 500);
        }, 3000);
    }
}

// 设置故障代码并更新显示
function setFailureCode(code) {
    console.log(`选择故障代码: '${code}'`, typeof code);
    
    // 确保code是字符串
    const codeStr = String(code);
    
    try {
        console.log(`当前故障代码选择器共有 ${failureCodeSelect.options.length} 个选项`);
        
        // 设置下拉框的值
        console.log(`正在设置故障代码选择器值为: '${codeStr}'`);
        
        // 调试：列出所有可用选项
        for (let i = 0; i < failureCodeSelect.options.length; i++) {
            console.log(`  选项 ${i}: 值='${failureCodeSelect.options[i].value}', 文本='${failureCodeSelect.options[i].text}'`);
        }
        
        // 尝试找到匹配选项
        let optionFound = false;
        for (let i = 0; i < failureCodeSelect.options.length; i++) {
            if (failureCodeSelect.options[i].value === codeStr) {
                console.log(`找到匹配选项索引 ${i}`);
                failureCodeSelect.selectedIndex = i;
                optionFound = true;
                break;
            }
        }
        
        if (!optionFound) {
            console.log(`警告：找不到值为 '${codeStr}' 的选项，尝试添加新选项`);
            
            // 如果找不到选项，尝试添加一个新选项
            const option = document.createElement('option');
            option.value = codeStr;
            option.textContent = `故障代码: ${codeStr}`;
            failureCodeSelect.appendChild(option);
            failureCodeSelect.value = codeStr;
            console.log(`已添加并选择新选项: ${codeStr}`);
            optionFound = true;
        }
        
        if (!optionFound) {
            console.error(`无法设置故障代码: ${codeStr}`);
            showStatusMessage(`无法找到故障代码 '${codeStr}' 的选项`, 'error');
            return;
        }
        
        // 更新全局变量
        selectedFailureCode = codeStr;
        
        // 调试信息
        console.log(`当前全局故障代码变量: '${selectedFailureCode}'`);
        console.log(`当前下拉框值: '${failureCodeSelect.value}'`);
        
        // 显示状态消息
        showStatusMessage(`已选择故障代码: ${codeStr}`, 'success');
        
        // 更新显示
        updateDisplay();
    } catch (error) {
        console.error(`设置故障代码时发生错误: ${error.message}`, error);
        showStatusMessage(`选择故障代码失败: ${error.message}`, 'error');
    }
}

// 导出到Excel
function exportToExcel() {
    if (!waferMap || Object.keys(waferMap).length === 0) {
        alert('请先生成晶圆映射');
        return;
    }
    
    // 创建一个工作簿
    const workbook = XLSX.utils.book_new();
    
    // 准备数据
    const selectedAsic = asicSelect.value;
    const selectedWafer = waferSelect.value;
    const locations = Object.values(waferMap);
    
    // 转换为Excel格式 - 位置数据
    const locationData = locations.map(loc => {
        // 准备故障代码分布数据
        const sbCodeDistribution = Object.entries(loc.sbCounts || {})
            .filter(([code]) => code !== '0' && code !== '1')
            .map(([code, count]) => `${code}:${count}`)
            .join(', ');
        
        return {
            'X坐标': loc.X,
            'Y坐标': loc.Y,
            'DIE总数': loc.locationTotal,
            '故障总数': loc.failureTotal,
            '故障率': loc.rate.toFixed(4),
            '故障代码分布': sbCodeDistribution
        };
    });
    
    // 创建位置数据工作表
    const locationWorksheet = XLSX.utils.json_to_sheet(locationData);
    
    // 添加位置数据工作表到工作簿
    XLSX.utils.book_append_sheet(workbook, locationWorksheet, `位置数据_${selectedWafer}`);
    
    // 收集所有故障的DIE
    const allFailureDies = locations.reduce((dies, loc) => {
        return dies.concat(loc.failureDies || []);
    }, []);
    
    // 按故障代码分组
    const failuresByCode = {};
    allFailureDies.forEach(die => {
        const code = die.sbCode || die.SB || 'unknown';
        if (!failuresByCode[code]) {
            failuresByCode[code] = [];
        }
        failuresByCode[code].push(die);
    });
    
    // 为每种故障代码创建工作表
    Object.entries(failuresByCode).forEach(([code, dies]) => {
        if (dies.length > 0) {
            const failureData = dies.map(die => ({
                'ASICID': die.ASICID || '',
                'X坐标': die.X,
                'Y坐标': die.Y,
                'SB': die.SB,
                'HB': die.HB,
                'stlot': die.stlot || '',
                'teststep': die.teststep || ''
            }));
            
            const failureWorksheet = XLSX.utils.json_to_sheet(failureData);
            XLSX.utils.book_append_sheet(workbook, failureWorksheet, `故障代码${code}_${selectedWafer}`);
        }
    });
    
    // 如果没有工作表，添加一个空工作表
    if (workbook.SheetNames.length === 0) {
        const emptyWorksheet = XLSX.utils.aoa_to_sheet([['没有故障数据']]);
        XLSX.utils.book_append_sheet(workbook, emptyWorksheet, '无故障数据');
    }
    
    // 导出Excel文件
    XLSX.writeFile(workbook, `晶圆映射_${selectedAsic}_${selectedWafer}.xlsx`);
}

// 导出图像
function exportImage() {
    if (!currentChart) {
        alert('请先生成晶圆映射');
        return;
    }
    
    // 获取canvas元素
    const canvas = document.getElementById('wafer-map');
    
    // 创建下载链接
    const link = document.createElement('a');
    link.download = `晶圆映射_${asicSelect.value}_${waferSelect.value}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// 更新显示
function updateDisplay() {
    if (waferMap && Object.keys(waferMap).length > 0) {
        // 检查当前是否是所有晶圆的映射图
        const isAllWaferMap = !asicSelect.value || !waferSelect.value;
        const title = isAllWaferMap ? '所有ASIC和晶圆' : `晶圆映射 - ASIC: ${asicSelect.value}, Wafer: ${waferSelect.value}`;
        
        console.log(`更新显示 - 当前选择的故障代码: ${selectedFailureCode}`);
        console.log(`更新显示 - 故障代码选择器值: ${failureCodeSelect.value}`);
        
        // 确保全局变量与选择器值一致
        selectedFailureCode = failureCodeSelect.value;
        
        // 显示状态信息
        showStatusMessage(`正在更新显示，故障代码: ${selectedFailureCode}`, 'info');
        
        try {
            // 绘制映射图
            drawWaferMap(waferMap, title);
            
            // 计算并显示基于所选故障代码的统计信息
            const statsWithRate = calculateFailureRateByCode(waferMap, selectedFailureCode);
            console.log(`计算了 ${Object.keys(statsWithRate).length} 个位置的故障率`);
            
            // 显示统计信息
            displayStats(statsWithRate);
            
            console.log(`显示更新完成，故障代码: ${selectedFailureCode}`);
            showStatusMessage(`显示已更新，故障代码: ${selectedFailureCode === 'all' ? '所有' : selectedFailureCode}`, 'success');
        } catch (error) {
            console.error(`更新显示时出错: ${error.message}`);
            showStatusMessage(`更新显示时出错: ${error.message}`, 'error');
        }
    } else {
        showStatusMessage('请先生成晶圆映射', 'error');
        alert('请先生成晶圆映射');
    }
}

// 生成所有晶圆的映射图
function generateAllWaferMap() {
    if (csvData.length === 0) {
        alert('请先上传并解析CSV文件');
        return;
    }
    
    // 使用所有数据
    const waferData = csvData;
    
    if (waferData.length === 0) {
        alert('未找到数据');
        return;
    }
    
    // 计算每个位置的统计数据
    const locationStats = calculateLocationStats(waferData);
    
    // 保存到全局变量
    waferMap = locationStats;
    
    // 重置故障代码选择器为"所有故障代码"
    failureCodeSelect.value = 'all';
    selectedFailureCode = 'all';
    
    // 绘制晶圆映射图
    drawWaferMap(locationStats, '所有ASIC和晶圆');
    
    // 显示统计信息
    displayStats(locationStats);
    
    // 启用导出按钮
    exportExcelBtn.disabled = false;
    exportImageBtn.disabled = false;
}

// 加载预定义坐标
async function loadPredefinedCoordinates() {
    const selectedCoordinateSet = predefinedCoordinatesSelect.value;
    
    if (!selectedCoordinateSet) {
        alert('请先选择预定义坐标集');
        return;
    }
    
    // 检查是否存在选定的预定义坐标集
    if (!predefinedCoordinates[selectedCoordinateSet]) {
        alert(`找不到预定义坐标集: ${selectedCoordinateSet}`);
        return;
    }
    
    const coordinatesData = predefinedCoordinates[selectedCoordinateSet];
    
    // 显示加载状态
    referenceInfoDiv.textContent = `正在加载坐标数据...`;
    
    try {
        // 判断是本地文件还是内置坐标
        if (coordinatesData.isLocalFile) {
            // 从本地Excel文件加载坐标
            const coordinates = await loadLocalReferenceFile(selectedCoordinateSet);
            
            if (!coordinates || coordinates.length === 0) {
                referenceInfoDiv.innerHTML = `无法从文件 ${coordinatesData.filePath} 加载坐标数据.<br>请检查文件是否存在并包含有效的X和Y坐标列`;
                return;
            }
            
            // 保存坐标数据
            referenceCoordinates = coordinates;
            
            // 显示成功消息
            referenceInfoDiv.innerHTML = `已从文件加载 ${coordinates.length} 个坐标点<br>
            <small>${coordinatesData.filePath}</small>`;
        } else {
            // 使用内置坐标
            referenceCoordinates = coordinatesData.coordinates;
            
            // 显示成功消息
            referenceInfoDiv.innerHTML = `已加载内置坐标: ${coordinatesData.description}<br>
            <small>共 ${referenceCoordinates.length} 个坐标点</small>`;
        }
        
        // 显示预览
        showReferencePreview(referenceCoordinates);
        
        // 如果已经生成了映射图，更新显示
        if (waferMap && Object.keys(waferMap).length > 0) {
            updateDisplay();
        }
    } catch (error) {
        console.error('加载坐标数据时出错:', error);
        referenceInfoDiv.innerHTML = `加载坐标数据时出错: ${error.message}`;
    }
}

// 加载参考坐标
function loadReferenceCoordinates() {
    if (!excelFile) {
        alert('请先上传参考文件');
        return;
    }
    
    const selectedSheet = referenceSheetSelect.value;
    if (!selectedSheet) {
        alert('请选择工作表');
        return;
    }
    
    referenceInfoDiv.textContent = `正在加载参考坐标...`;
    
    // 检查文件类型
    const fileType = excelFile.name.split('.').pop().toLowerCase();
    
    if (fileType === 'xlsx' || fileType === 'xls') {
        // 读取Excel文件
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                // 使用SheetJS库解析Excel文件
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                
                // 获取选定的工作表
                const worksheet = workbook.Sheets[selectedSheet];
                
                // 将工作表转换为JSON
                const jsonData = XLSX.utils.sheet_to_json(worksheet);
                
                // 处理坐标数据
                processCoordinatesData(jsonData, 'Excel');
                
            } catch (error) {
                console.error('解析Excel文件时出错:', error);
                referenceInfoDiv.textContent = `解析Excel文件时出错: ${error.message}`;
            }
        };
        
        reader.onerror = function() {
            referenceInfoDiv.textContent = '读取文件时出错';
        };
        
        reader.readAsArrayBuffer(excelFile);
    } else {
        referenceInfoDiv.textContent = `不支持的文件类型: ${fileType}，仅支持Excel文件从工作表中加载数据`;
    }
}

// 生成测试映射图
function generateTestMap() {
    console.log('生成测试映射图');
    showStatusMessage('正在生成测试映射图...', 'info');
    
    // 创建测试数据
    const testData = [];
    
    // 生成一个10x10的网格，有一些随机故障
    for (let x = 0; x < 10; x++) {
        for (let y = 0; y < 10; y++) {
            // 每个位置添加5个DIE
            for (let i = 0; i < 5; i++) {
                const randomSb = Math.random() < 0.8 ? '0' : 
                                 Math.random() < 0.5 ? '1' : 
                                 ['TEST1', 'TEST2', 'TEST3'][Math.floor(Math.random() * 3)];
                
                testData.push({
                    stlot: 'TEST-LOT',
                    teststep: 'TEST-STEP',
                    asic: 'TEST-ASIC',
                    wafer: '1',
                    X: x,
                    Y: y,
                    HB: '0',
                    SB: randomSb,
                    ASICID: `TEST-ID-${x}-${y}-${i}`
                });
            }
        }
    }
    
    // 保存测试数据
    csvData = testData;
    
    // 更新故障代码
    const sbValues = new Set();
    testData.forEach(row => {
        if (row.SB && row.SB !== '0' && row.SB !== '1') {
            sbValues.add(row.SB);
        }
    });
    
    // 更新全局故障代码列表
    sbFailureCodes = Array.from(sbValues).sort();
    console.log(`测试数据中的故障代码:`, sbFailureCodes);
    
    // 更新选择器
    updateFailureCodeSelector();
    
    // 计算位置统计
    const locationStats = calculateLocationStats(testData);
    waferMap = locationStats;
    
    // 绘制映射图
    drawWaferMap(locationStats, '测试晶圆映射图');
    
    // 显示统计信息
    displayStats(locationStats);
    
    // 启用按钮
    generateMapBtn.disabled = false;
    generateAllMapBtn.disabled = false;
    exportExcelBtn.disabled = false;
    exportImageBtn.disabled = false;
    
    showStatusMessage('测试映射图已生成', 'success');
} 